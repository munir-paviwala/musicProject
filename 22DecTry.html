<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sonic Gallery: The Listener</title>
    <style>
        body { margin: 0; background: #000; color: white; font-family: 'Helvetica Neue', sans-serif; overflow: hidden; }
        #canvas { display: block; cursor: grab; }
        #canvas:active { cursor: grabbing; }
        
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; mix-blend-mode: difference; z-index: 20; }
        
        /* JOURNEY PANEL */
        #journey-panel {
            position: absolute; top: 150px; left: 20px; pointer-events: auto;
            display: flex; flex-direction: column; gap: 10px;
        }
        .journey-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 10px 20px; border-radius: 20px; cursor: pointer;
            backdrop-filter: blur(5px); font-size: 0.9em; transition: all 0.2s;
            text-align: left; display: flex; align-items: center; gap: 10px;
        }
        .journey-btn:hover { background: rgba(255,255,255,0.3); transform: translateX(5px); }
        
        #auto-btn { 
            border-color: #00ffff; color: #00ffff; background: rgba(0, 255, 255, 0.1); 
            display: none; 
        }
        #skip-btn {
            border-color: #ffaa00; color: #ffaa00; background: rgba(255, 170, 0, 0.1);
            display: none; /* Only shows when listening in autopilot */
        }

        /* NOW PLAYING */
        #now-playing {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 400px; background: rgba(10, 10, 10, 0.8); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.15); padding: 15px 25px; border-radius: 30px; 
            display: none; text-align: center; z-index: 90;
        }
        #np-title { font-weight: 700; font-size: 1.1em; color: #fff; margin-bottom: 5px;}
        
        #video-dock {
            position: absolute; bottom: 30px; right: 30px;
            width: 320px; height: 180px; background: #000; border: 2px solid #333; border-radius: 12px;
            overflow: hidden; z-index: 100; display: none; 
            transition: all 0.4s;
        }
        #video-dock:hover { width: 640px; height: 360px; border-color: white; transform: translate(-20px, -20px); }
        #yt-player-wrapper { width: 100%; height: 100%; pointer-events: none; } 
        #video-dock:hover #yt-player-wrapper { pointer-events: auto; }

        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999;
        }
        #start-btn { padding: 15px 40px; font-size: 1.2em; cursor: pointer; border-radius: 50px; font-weight: bold; border:none;}
    </style>
</head>
<body>

<div id="start-screen">
    <h1>The Sonic Archive</h1>
    <p style="color: #888; margin-bottom: 20px;">Use Local Server / GitHub Pages</p>
    <button id="start-btn">BEGIN EXPLORATION</button>
</div>

<div id="ui">
    <h2>Phase 13: The Listener</h2>
    <p>Autopilot stops to listen.</p>
</div>

<div id="journey-panel">
    <button class="journey-btn" onclick="startRandomJourney()">üé≤ Guide Me Somewhere</button>
    <button id="auto-btn" class="journey-btn" onclick="toggleAutopilot()">‚ñ∂ Start Tour</button>
    <button id="skip-btn" class="journey-btn" onclick="forceNextSong()">‚è≠ Skip to Next</button>
    <button class="journey-btn" onclick="clearTrace()">üßπ Erase Memory Trace</button>
    <button class="journey-btn" onclick="clearGuide()" id="clear-guide-btn" style="display:none; border-color: #ff4444; color: #ff8888;">‚ùå Stop Guide</button>
</div>

<div id="now-playing">
    <div id="np-title">Song Title</div>
    <div id="np-status" style="font-size: 0.8em; color: cyan; margin-bottom: 5px; display:none;">AUTOPILOT: LISTENING...</div>
    <div id="np-note" style="color:#aaa; font-style:italic; font-size:0.9em;"></div>
</div>

<div id="video-dock"><div id="yt-player-wrapper"></div></div>
<canvas id="canvas"></canvas>

<script src="https://www.youtube.com/iframe_api"></script>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const fogCanvas = document.createElement('canvas');
const fogCtx = fogCanvas.getContext('2d');

// GAME STATE
let player = { x: 0, y: 0, size: 8 };
let camera = { zoom: 1, targetZoom: 1 };
let keys = {};
let mouse = { x: 0, y: 0, dragging: false };
let pathHistory = []; 
let guidePath = null; 
let guideTarget = null; 

// AUTOPILOT STATE
let isAutopilot = false;
let autopilotState = "IDLE"; // "MOVING" or "LISTENING"
let autopilotIndex = 1; 

// DATA
let songs = [];
let anchors = [];

fetch('data.json').then(r => r.json()).then(data => {
    songs = data.songs || [];
    anchors = data.anchors || [];
}).catch(e => console.error("Data Error:", e));

// ==========================================
// 1. SMART PATHFINDING
// ==========================================
function startRandomJourney() {
    if (songs.length < 2) return alert("Not enough songs!");
    
    // Pick far away target
    let farSongs = songs.filter(s => Math.sqrt((s.x-player.x)**2 + (s.y-player.y)**2) > 400);
    let target = farSongs.length > 0 ? farSongs[Math.floor(Math.random() * farSongs.length)] : songs[Math.floor(Math.random() * songs.length)];
    guideTarget = target;
    
    // Find stops along the way
    let waypoints = [];
    let vectorX = target.x - player.x;
    let vectorY = target.y - player.y;
    let totalDist = Math.sqrt(vectorX*vectorX + vectorY*vectorY);
    
    songs.forEach(s => {
        if (s === target) return;
        let sx = s.x - player.x;
        let sy = s.y - player.y;
        let dot = (sx * vectorX + sy * vectorY) / (totalDist * totalDist);
        if (dot > 0.1 && dot < 0.9) {
            let projX = player.x + dot * vectorX;
            let projY = player.y + dot * vectorY;
            if (Math.sqrt((s.x - projX)**2 + (s.y - projY)**2) < 200) waypoints.push(s);
        }
    });

    // Sort by distance
    waypoints.sort((a, b) => ((a.x - player.x)**2 + (a.y - player.y)**2) - ((b.x - player.x)**2 + (b.y - player.y)**2));
    if (waypoints.length > 3) waypoints = [waypoints[0], waypoints[Math.floor(waypoints.length/2)], waypoints[waypoints.length-1]];

    // Build Path
    guidePath = [];
    guidePath.push({x: player.x, y: player.y}); 
    waypoints.forEach(wp => guidePath.push({x: wp.x, y: wp.y})); 
    guidePath.push({x: target.x, y: target.y});
    
    // UI
    document.getElementById('clear-guide-btn').style.display = 'flex';
    document.getElementById('auto-btn').style.display = 'flex';
    document.getElementById('auto-btn').innerText = "‚ñ∂ Start Tour";
    
    // Reset
    isAutopilot = false; 
    autopilotIndex = 1; 
    autopilotState = "IDLE";
    camera.targetZoom = 0.6;
}

function toggleAutopilot() {
    if (!guidePath) return;
    isAutopilot = !isAutopilot;
    document.getElementById('auto-btn').innerText = isAutopilot ? "‚è∏ Pause Tour" : "‚ñ∂ Start Tour";
    
    if(isAutopilot) {
        if (currentSongId) {
            autopilotState = "LISTENING";
            document.getElementById('np-status').style.display = "block";
            document.getElementById('np-status').innerText = "AUTOPILOT: LISTENING...";
            document.getElementById('skip-btn').style.display = 'flex';
        } else {
            autopilotState = "MOVING";
        }
        camera.targetZoom = 0.8;
    } else {
        document.getElementById('skip-btn').style.display = 'none';
        document.getElementById('np-status').style.display = 'none';
    }
}

function forceNextSong() {
    if(!isAutopilot) return;
    
    // Stop current
    stopSong(); 
    currentSongId = null; 

    // Move to next
    autopilotIndex++;
    
    // Check end
    if (autopilotIndex >= guidePath.length) {
        clearGuide(); 
    } else {
        autopilotState = "MOVING";
        document.getElementById('skip-btn').style.display = 'none';
        document.getElementById('np-status').innerText = "MOVING TO NEXT STOP...";
    }
}

function clearGuide() {
    guidePath = null; guideTarget = null; isAutopilot = false;
    document.getElementById('clear-guide-btn').style.display = 'none';
    document.getElementById('auto-btn').style.display = 'none';
    document.getElementById('skip-btn').style.display = 'none';
    document.getElementById('auto-btn').innerText = "‚ñ∂ Start Tour";
    document.getElementById('np-status').style.display = 'none';
}

function clearTrace() { pathHistory = []; }

// ==========================================
// 2. YOUTUBE
// ==========================================
let playerInstance = null;
let currentSongId = null;

function onYouTubeIframeAPIReady() {
    playerInstance = new YT.Player('yt-player-wrapper', {
        height: '100%', width: '100%', videoId: '',
        playerVars: { 'playsinline': 1, 'controls': 1, 'disablekb': 1 },
        events: { 'onStateChange': onPlayerStateChange }
    });
}

function onPlayerStateChange(event) {
    if (event.data === 0 && isAutopilot && autopilotState === "LISTENING") {
        console.log("Song finished naturally.");
        forceNextSong();
    }
}

function playSong(song) {
    if (!playerInstance || !playerInstance.loadVideoById) return;
    document.getElementById('video-dock').style.display = "block";
    playerInstance.loadVideoById(song.ytId);
    document.getElementById('np-title').innerText = song.title;
    document.getElementById('np-note').innerText = song.note || "";
    document.getElementById('now-playing').style.display = "block";
}

function stopSong() {
    if (playerInstance && playerInstance.stopVideo) playerInstance.stopVideo();
    document.getElementById('video-dock').style.display = "none";
    document.getElementById('now-playing').style.display = "none";
}

// ==========================================
// 3. INPUTS
// ==========================================
window.addEventListener('resize', resize);
function resize() { 
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    fogCanvas.width = 4000; fogCanvas.height = 4000;
    fogCtx.fillStyle = "rgba(0, 0, 0, 0.40)"; 
    fogCtx.fillRect(0, 0, 4000, 4000);
    fogCtx.globalCompositeOperation = "destination-out";
    fogCtx.beginPath(); fogCtx.arc(2000, 2000, 300, 0, Math.PI*2); fogCtx.fill();
    fogCtx.globalCompositeOperation = "source-over";
}
resize();

document.getElementById('start-btn').addEventListener('click', () => {
    document.getElementById('start-screen').style.display = 'none';
    if(playerInstance) playerInstance.playVideo();
    setTimeout(() => { if(playerInstance) playerInstance.stopVideo(); }, 100);
});

window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (isAutopilot && (e.key==='w'||e.key==='a'||e.key==='s'||e.key==='d')) toggleAutopilot(); 
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('wheel', e => {
    e.preventDefault();
    camera.targetZoom = Math.max(0.2, Math.min(3.0, camera.targetZoom - e.deltaY * 0.001));
}, { passive: false });
canvas.addEventListener('mousedown', e => { 
    mouse.dragging = true; mouse.x = e.clientX; mouse.y = e.clientY; 
    if(isAutopilot) toggleAutopilot(); 
});
window.addEventListener('mouseup', () => mouse.dragging = false);
canvas.addEventListener('mousemove', e => {
    if(mouse.dragging) {
        player.x -= (e.clientX - mouse.x) / camera.zoom;
        player.y -= (e.clientY - mouse.y) / camera.zoom;
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    }
});


// ==========================================
// 4. RENDER LOOP
// ==========================================
let time = 0;
function draw() {
    time += 0.04; 

    // --- AUTOPILOT LOGIC ---
    if (isAutopilot && guidePath && autopilotIndex < guidePath.length) {
        
        if (autopilotState === "MOVING") {
            let target = guidePath[autopilotIndex];
            let dx = target.x - player.x;
            let dy = target.y - player.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            // THE FIX: Use "Fuzzy" match (allow 1px error) to detect songs
            let isTargetSong = songs.find(s => Math.abs(s.x - target.x) < 1 && Math.abs(s.y - target.y) < 1);
            
            if (dist < 10) {
                // ARRIVED AT WAYPOINT
                if (isTargetSong) {
                    // It is a song! Switch to listening.
                    autopilotState = "LISTENING";
                    document.getElementById('np-status').style.display = "block";
                    document.getElementById('np-status').innerText = "AUTOPILOT: LISTENING...";
                    document.getElementById('skip-btn').style.display = 'flex';
                } else {
                    // Just a path point. Keep moving.
                    autopilotIndex++;
                    if (autopilotIndex >= guidePath.length) clearGuide();
                }
            } else {
                // Move towards waypoint
                let moveSpeed = 4.0 / camera.zoom;
                player.x += (dx / dist) * moveSpeed;
                player.y += (dy / dist) * moveSpeed;
            }
        }
    } else {
        // MANUAL MODE
        if (keys['w']) player.y -= 6/camera.zoom;
        if (keys['s']) player.y += 6/camera.zoom;
        if (keys['a']) player.x -= 6/camera.zoom;
        if (keys['d']) player.x += 6/camera.zoom;
    }

    camera.zoom += (camera.targetZoom - camera.zoom) * 0.1;

    // Trace
    if (pathHistory.length === 0 || Math.abs(player.x - pathHistory[pathHistory.length-1].x) > 10 || Math.abs(player.y - pathHistory[pathHistory.length-1].y) > 10) {
        pathHistory.push({x: player.x, y: player.y});
    }

    // Fog
    let fogX = player.x + 2000;
    let fogY = player.y + 2000;
    fogCtx.globalCompositeOperation = "destination-out";
    fogCtx.beginPath(); fogCtx.arc(fogX, fogY, 150, 0, Math.PI*2); fogCtx.fill();
    fogCtx.globalCompositeOperation = "source-over";

    // DRAW SCENE
    ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-player.x, -player.y);

    // Anchors
    ctx.globalCompositeOperation = "screen"; 
    anchors.forEach(a => {
        let grad = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, a.radius);
        grad.addColorStop(0, a.color); grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(a.x, a.y, a.radius, 0, Math.PI*2); ctx.fill();
    });
    ctx.globalCompositeOperation = "source-over";

    // Trace
    if (pathHistory.length > 1) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.15)"; ctx.lineWidth = 2; ctx.beginPath();
        ctx.moveTo(pathHistory[0].x, pathHistory[0].y);
        for(let i=1; i<pathHistory.length; i++) ctx.lineTo(pathHistory[i].x, pathHistory[i].y);
        ctx.stroke();
    }

    // Guide Line
    if (guidePath && guidePath.length > 1) {
        ctx.strokeStyle = isAutopilot ? "rgba(0, 255, 255, 0.8)" : "rgba(0, 255, 255, 0.4)";
        ctx.lineWidth = 3; ctx.setLineDash([15, 10]); ctx.beginPath();
        
        let startIdx = autopilotIndex > 0 ? autopilotIndex - 1 : 0;
        ctx.moveTo(player.x, player.y);
        for(let i=autopilotIndex; i<guidePath.length; i++) ctx.lineTo(guidePath[i].x, guidePath[i].y);
        ctx.stroke(); ctx.setLineDash([]);
        
        // Draw Stops (Visual Feedback)
        for(let i=autopilotIndex; i<guidePath.length; i++) {
            let pt = guidePath[i];
            // Only draw dots if it matches a song
            if (songs.some(s => Math.abs(s.x-pt.x)<1 && Math.abs(s.y-pt.y)<1)) {
                ctx.fillStyle = "cyan"; ctx.beginPath(); ctx.arc(pt.x, pt.y, 6, 0, Math.PI*2); ctx.fill();
            }
        }
        
        let end = guidePath[guidePath.length-1];
        ctx.shadowBlur = 10; ctx.shadowColor = "cyan"; ctx.fillStyle = "cyan"; ctx.beginPath(); ctx.arc(end.x, end.y, 8, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
    }

    // Songs
    let touching = false;
    songs.forEach(s => {
        let floatY = s.y + Math.sin(time + s.offset) * 6;
        let dist = Math.sqrt((player.x-s.x)**2 + (player.y-floatY)**2);
        let isTouching = dist < (35 + player.size);
        let r = isTouching ? 50 : 35;
        
        if (guidePath && guidePath.some(pt => Math.abs(pt.x-s.x)<1 && Math.abs(pt.y-s.y)<1)) {
            ctx.strokeStyle = "cyan"; ctx.lineWidth = 3;
        } else {
            ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 1.5;
        }

        ctx.beginPath(); ctx.arc(s.x, floatY, r, 0, Math.PI*2);
        
        if (isTouching) {
            touching = true;
            ctx.shadowBlur = 30; ctx.shadowColor = "white"; ctx.fillStyle = "white"; ctx.fill(); ctx.shadowBlur = 0;
            if(currentSongId !== s.id) { playSong(s); currentSongId = s.id; }
        } else {
            ctx.fillStyle = "rgba(255,255,255,0.05)"; ctx.fill(); ctx.stroke();
        }

        if (camera.zoom > 0.5) {
             ctx.fillStyle = isTouching ? "black" : "rgba(255,255,255,0.7)";
             ctx.font = isTouching ? "bold 12px Arial" : "11px Arial";
             ctx.textAlign = "center"; ctx.fillText(s.title, s.x, floatY + r + 15);
        }
    });

    if(!touching && currentSongId && !isAutopilot) { stopSong(); currentSongId = null; }

    ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI*2); ctx.fill();

    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.drawImage(fogCanvas, -2000, -2000);
    ctx.restore();

    ctx.restore();
    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>